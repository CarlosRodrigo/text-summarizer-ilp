package br.ufrpe.ILP;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

import net.sf.javailp.Constraint;
import net.sf.javailp.Linear;
import net.sf.javailp.OptType;
import net.sf.javailp.Problem;
import net.sf.javailp.Result;
import net.sf.javailp.Solver;
import net.sf.javailp.SolverFactory;
import net.sf.javailp.SolverFactoryGurobi;
import br.ufrpe.nlptoolkit.models.Sentence;
import br.ufrpe.nlptoolkit.models.Token;
import br.ufrpe.utils.Utils;

/**
 * 
 * @author Hilario Tomaz Alves de Oliveira
 *
 */

public class ILPParser {

	// Constructor

	public ILPParser() {

	}

	// Methods

	public List<Sentence> executeILPOptimization(
			HashMap<Token, ArrayList<Sentence>> mapConceptsentences,
			boolean isWordCount, int summarizationThreshold,
			boolean isUseEntityGraph,
			ArrayList<ArrayList<String>> excludedSolutions) {

		// Creation of the problem

		Problem problem = new Problem();

		// Creation of the objective function

		Linear objectiveFunction = new Linear();

		int idConcept = 1;

		// Insertion into the objective function the equation wi (concept
		// weight) * ci (concept)

		for (Token concept : mapConceptsentences.keySet()) {

			concept.setId(idConcept++);

			String label = "c_" + concept.getId();

			objectiveFunction.add(concept.getScore(), label);

			problem.setVarLowerBound(label, 0);
			problem.setVarUpperBound(label, 1);

			problem.setVarType(label, Integer.class);

		} // FOR CONCEPTS

		Set<Sentence> sentences = new HashSet<Sentence>();

		for (List<Sentence> listSentences : mapConceptsentences.values()) {

			sentences.addAll(listSentences);

		} // FOR SENTENCES MAP

		if (isUseEntityGraph) {

			// Insertion into the objective function the equation wi (sentence
			// weight generated by the entity graph) * si (sentence)

			for (Sentence sentence : sentences) {

				String label = "s_" + sentence.getIdString();

				objectiveFunction.add(sentence.getCohesion(), label);

				problem.setVarLowerBound(label, 0);
				problem.setVarUpperBound(label, 1);

				problem.setVarType(label, Integer.class);

			} // FOR SENTENCES

		}

		problem.setObjective(objectiveFunction, OptType.MAX);

		// Summary length constraint

		Linear constraintSentenceLength = new Linear();

		for (Sentence sentence : sentences) {

			String labelSentence = "s_" + sentence.getIdString();

			if (isWordCount) {

				int sentenceSize = Utils.getSentenceSize(sentence);

				constraintSentenceLength.add(sentenceSize, labelSentence);

			} else {

				constraintSentenceLength.add(1, labelSentence);

			}

			problem.setVarLowerBound(labelSentence, 0);
			problem.setVarUpperBound(labelSentence, 1);

			problem.setVarType(labelSentence, Integer.class);

		} // FOR SENTECES

		// Add into the problem the summary length constraint

		problem.add(new Constraint("Constraint_SummaryLength",
				constraintSentenceLength, "<=", summarizationThreshold));

		// Sentences dependency constraint

		int idConstraint = 1;

		for (Sentence sentence : sentences) {

			if (sentence.getMapSentencesDependency() != null) {

				String labelSentence = "s_" + sentence.getIdString();

				for (Entry<String, List<Sentence>> entry : sentence
						.getMapSentencesDependency().entrySet()) {

					for (Sentence sentenceDependency : entry.getValue()) {

						String labelSentenceDependency = "s_"
								+ sentenceDependency.getIdString();

						Linear constraintDiscourseRelation = new Linear();

						constraintDiscourseRelation.add(-1, labelSentence);
						constraintDiscourseRelation.add(1,
								labelSentenceDependency);

						problem.add(new Constraint(
								"Constraint_SentenceDependency"
										+ idConstraint++,
								constraintDiscourseRelation, ">=", 0));

					} // FOR SENTENCES

				} // FOR MAP DEPENDENCIES

			}

		} // FOR SENTENCES

		// Sentences removed constraint

		idConstraint = 1;

		for (Sentence sentence : sentences) {

			if (sentence.isRemoved()) {

				Linear constraintSentencesRemoved = new Linear();

				String labelSentence = "s_" + sentence.getIdString();

				constraintSentencesRemoved.add(-1, labelSentence);

				problem.add(new Constraint("Constraint_SentenceRemoved"
						+ idConstraint++, constraintSentencesRemoved, ">=", 0));

			}

		} // FOR SENTENCES

		/*
		 * Constraints that guarantees the integrity of the model
		 * 
		 * a) If one concept is selected this means that this concept is in at
		 * least one selected sentence. b) If one sentence is selected this
		 * means that all concepts of this sentences are selected.
		 */

		idConstraint = 1;

		for (Entry<Token, ArrayList<Sentence>> entry : mapConceptsentences
				.entrySet()) {

			Linear constraintConceptSentences = new Linear();

			String labelConcept = "c_" + entry.getKey().getId();

			constraintConceptSentences.add(-1, labelConcept);

			Set<String> sentencesIds = new HashSet<String>();

			for (int i = 0; i < entry.getValue().size(); i++) {

				Sentence sentence = entry.getValue().get(i);

				if (sentencesIds.contains(sentence.getIdString())) {

					continue;

				}

				sentencesIds.add(sentence.getIdString());

				Linear constraintConceptSentence = new Linear();

				String labelSentence = "s_" + sentence.getIdString();

				constraintConceptSentence.add(-1, labelConcept);
				constraintConceptSentence.add(1, labelSentence);

				problem.add(new Constraint("Constraint_ConceptSentence"
						+ idConstraint++, constraintConceptSentence, "<=", 0));

				constraintConceptSentences.add(1, labelSentence);

			} // FOR SENTENCES

			problem.add(new Constraint("Constraint_ConceptSentences"
					+ idConstraint++, constraintConceptSentences, ">=", 0));

		} // FOR MAP CONCEPTS SENTENCES

		// Constraint used to avoid some given solutions

		if (excludedSolutions != null && !excludedSolutions.isEmpty()) {

			for (ArrayList<String> idSentencesExcludedSolution : excludedSolutions) {

				Linear constraintExcludedSolution = new Linear();

				for (String idSentence : idSentencesExcludedSolution) {

					String labelSentence = "s_" + idSentence;

					constraintExcludedSolution.add(1, labelSentence);

				} // FOR ID SENTENCES

				problem.add(new Constraint("Constraint_ExcluedSolution"
						+ idConstraint++, constraintExcludedSolution, "<=",
						(idSentencesExcludedSolution.size() - 1)));

			} // FOR EXCLUDED SOLUTIONS

		}

		// Initialization of the Solver

		SolverFactory factory = new SolverFactoryGurobi();

		factory.setParameter(Solver.VERBOSE, 0);
		factory.setParameter(Solver.TIMEOUT, 100); // set timeout to 100 seconds

		Solver solver = factory.get();

		// Get the result of the ILP problem

		System.out.println(problem);
		Result result = solver.solve(problem);
		System.out.println(result);

		List<Sentence> selectedSentences = new ArrayList<Sentence>();

		// Get the sentences selected by the solution of the ILP model

		for (Sentence sentence : sentences) {

			int index = (int) result.get("s_" + sentence.getIdString());

			if (index == 1) {

				sentence.setSalienceScore(result.getObjective().doubleValue());

				selectedSentences.add(sentence);

			}

		} // FOR SENTENCES

		return selectedSentences.isEmpty() ? null : selectedSentences;

	}

}
